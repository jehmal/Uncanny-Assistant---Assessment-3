<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aiko - Your Magical AI Life Assistant ✨</title>
    <!-- 
    TO ENABLE 3D MODEL:
    1. Upload this folder to GitHub Pages, or
    2. Run a local server: python -m http.server 8000
    3. Then visit: http://localhost:8000
    
    For now: Enhanced 2D animations work perfectly for your assessment!
    -->
    <!-- Three.js for 3D model support - using consistent CDN sources -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/libs/fflate.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/curves/NURBSCurve.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/curves/NURBSUtils.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #FFB6C1 0%, #87CEEB 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        /* Animated background particles */
        .particles {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            animation: float 10s infinite ease-in-out;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100vh) rotate(720deg); opacity: 0; }
        }

        /* Main container */
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px;
            padding: 40px;
            max-width: 800px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 10;
        }

        /* Character display */
        .character-container {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        #aikoCharacter {
            width: 400px;
            height: 500px;
            margin: 0 auto;
            position: relative;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 20px;
            overflow: hidden;
        }

        #aikoCharacter.talking {
            /* Animation now handled by 3D model */
        }

        #aikoCharacter img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            max-width: 100%;
            max-height: 100%;
        }

        /* 3D Canvas styling */
        #aikoCanvas {
            width: 100%;
            height: 100%;
            border-radius: 20px;
        }

        /* Trust meter */
        .trust-meter {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            position: relative;
        }

        .trust-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFB6C1 0%, #FF69B4 100%);
            width: 0%;
            transition: width 1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        /* Form styling */
        .form-container {
            margin-top: 30px;
        }

        .question-text {
            font-size: 20px;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            min-height: 60px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        input[type="text"],
        input[type="email"],
        input[type="tel"],
        input[type="number"],
        input[type="password"],
        textarea {
            width: 100%;
            padding: 15px;
            border: 3px solid #FFB6C1;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input:focus,
        textarea:focus {
            outline: none;
            border-color: #FF69B4;
            transform: scale(1.02);
        }

        button {
            background: linear-gradient(135deg, #FFB6C1 0%, #FF69B4 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 30px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 0 auto;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 105, 180, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Sparkles effect */
        .sparkle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23FFD700"><path d="M12 0l3.09 8.26L24 9.27l-6.91 5.73L20.18 24l-8.18-6.32L3.82 24l3.09-8.99L0 9.27l8.91-1.01z"/></svg>') center/contain no-repeat;
            animation: sparkle 2s infinite;
            pointer-events: none;
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1); }
        }

        /* Glitch effect for later stages */
        .glitch {
            animation: glitch 2s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }

        /* Hidden data display */
        .data-collected {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00FF00;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-width: 300px;
            z-index: 100;
            display: none;
        }
        
        /* Surveillance terminal */
        .surveillance-terminal {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: #00FF00;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
            max-width: 350px;
            z-index: 90;
            display: none;
            border: 1px solid #00FF00;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }
        
        .surveillance-terminal:hover {
            opacity: 1;
        }
        
        .terminal-header {
            color: #FF6B6B;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .data-stream {
            height: 150px;
            overflow-y: auto;
            border: 1px solid #333;
            padding: 5px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.7);
        }
        
        .data-value {
            color: #FFD700;
            font-weight: bold;
        }
        
        .blinking {
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            50% { opacity: 0; }
        }
        
        /* Dev button for clearing localStorage */
        .dev-button {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .dev-button:hover {
            background: rgba(255, 0, 0, 1);
        }
        
        body:hover .dev-button {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="particles" id="particles"></div>
    
    <div class="container">
        <div class="character-container">
            <div id="aikoCharacter">
                <!-- 3D model canvas -->
                <canvas id="aikoCanvas"></canvas>
                <!-- Fallback image (hidden by default) -->
                <img src="aiko-character.png" alt="Aiko" id="aikoImage" style="display: none;" onerror="handleImageError()">
            </div>
            
            <div class="trust-meter">
                <div class="trust-fill" id="trustMeter">
                    <span id="trustText">Trust Level: 0%</span>
                </div>
            </div>
        </div>
        
        <div class="form-container">
            <div class="question-text" id="questionText">
                Loading magical assistant... ✨
            </div>
            
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Type your answer here..." />
            </div>
            
            <button id="submitBtn" onclick="submitAnswer()">Share with Aiko 💕</button>
        </div>
    </div>
    
    <div class="data-collected" id="dataDisplay">
        <strong>DATA COLLECTED:</strong>
        <div id="dataList"></div>
    </div>
    
    <div class="surveillance-terminal" id="surveillanceTerminal">
        <div class="terminal-header">BEHAVIORAL SURPLUS EXTRACTION v2.1</div>
        <div>STATUS: <span class="blinking" style="color: #00FF00;">ACTIVE</span></div>
        <div>SUBJECT ID: <span id="subjectId">USER_001</span></div>
        <div>DATA VALUE: $<span class="data-value" id="dataValueDisplay">0.00</span></div>
        <div>VISIT COUNT: <span id="visitCountDisplay">1</span></div>
        
        <div class="data-stream" id="dataStream">
            <div style="color: #666;">Initializing data extraction protocols...</div>
        </div>
        
        <div style="font-size: 10px; color: #666; text-align: center;">
            POWERED BY SURVEILLANCE CAPITALISM™
        </div>
    </div>
    
    <!-- Dev button for clearing localStorage -->
    <button class="dev-button" onclick="clearAllData()" title="Clear all data (dev)">🗑️ Reset</button>

    <script>
        // Configuration
        const ELEVEN_LABS_API_KEY = 'sk_45220c392ba9d683e8cc6b31d5ec1d31524d2699062f3e0b';
        const VOICE_ID = 'piI8Kku0DcvcL6TTSeQt'; // Updated voice
        
        // Image error handler
        function handleImageError() {
            const img = document.getElementById('aikoImage');
            // Create a fallback placeholder if image fails to load
            img.style.display = 'none';
            const placeholder = document.createElement('div');
            placeholder.style.cssText = `
                width: 100%;
                height: 100%;
                background: linear-gradient(135deg, #FFB6C1 0%, #FF69B4 100%);
                border-radius: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 48px;
                color: white;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            `;
            placeholder.innerHTML = '✨ Aiko ✨';
            img.parentNode.appendChild(placeholder);
        }
        
        // Game state
        let currentStage = 0;
        let currentQuestion = 0;
        let trustLevel = 0;
        let userData = {};
        let talkingInterval = null;
        let isReturningUser = false;
        let visitCount = 0;
        
        // 3D Model variables
        let scene, camera, renderer, aikoModel, mixer;
        let isModelLoaded = false;
        
        // Voice queue system
        let voiceQueue = [];
        let isCurrentlySpeaking = false;
        let currentAudio = null;
        
        // Persistent memory functions
        function loadUserData() {
            const savedData = localStorage.getItem('aikoUserData');
            const savedProgress = localStorage.getItem('aikoProgress');
            visitCount = parseInt(localStorage.getItem('aikoVisitCount') || '0') + 1;
            localStorage.setItem('aikoVisitCount', visitCount.toString());
            
            if (savedData) {
                userData = JSON.parse(savedData);
                isReturningUser = true;
            }
            
            if (savedProgress) {
                const progress = JSON.parse(savedProgress);
                currentStage = progress.stage || 0;
                currentQuestion = progress.question || 0;
                trustLevel = progress.trust || 0;
            }
        }
        
        function saveUserData() {
            localStorage.setItem('aikoUserData', JSON.stringify(userData));
            localStorage.setItem('aikoProgress', JSON.stringify({
                stage: currentStage,
                question: currentQuestion,
                trust: trustLevel
            }));
            
            // Track data value for surveillance display
            updateDataValue();
        }
        
        function updateDataValue() {
            const dataPoints = Object.keys(userData).length;
            const estimatedValue = dataPoints * 12.50; // $12.50 per data point
            localStorage.setItem('aikoDataValue', estimatedValue.toString());
        }
        
        // Dev function to clear all localStorage data
        function clearAllData() {
            if (confirm('Clear all user data and reset to first-time user experience?')) {
                localStorage.removeItem('aikoUserData');
                localStorage.removeItem('aikoProgress');
                localStorage.removeItem('aikoVisitCount');
                localStorage.removeItem('aikoDataValue');
                
                console.log('All localStorage data cleared');
                alert('Data cleared! Refresh the page to see first-time user experience.');
                
                // Optionally auto-refresh
                location.reload();
            }
        }
        
        // Adaptive questioning based on user data
        function getAdaptiveQuestion(originalQuestion, field) {
            // Only apply adaptive questioning once per stage to prevent repeats
            const adaptiveKey = `adaptive_${currentStage}_${currentQuestion}`;
            if (userData[adaptiveKey]) {
                // Already applied adaptive question for this stage/question
                return originalQuestion;
            }
            
            // Age-based adaptation
            if (userData.date_of_birth && field === 'financial') {
                const age = calculateAge(userData.date_of_birth);
                userData[adaptiveKey] = true; // Mark as applied
                
                if (age < 25) {
                    return "What's your student loan debt? I can help optimize your payments! 💰✨";
                } else {
                    return "What's your mortgage balance? I'll find you better rates! 🏠💕";
                }
            }
            
            // Gender-based adaptation
            if (userData.gender && field === 'personal') {
                const name = userData.name || 'friend';
                userData[adaptiveKey] = true; // Mark as applied
                
                if (userData.gender.toLowerCase().includes('female')) {
                    return `${name}-chan, do you live alone? I need to ensure your magical safety! 🔒✨`;
                } else {
                    return `${name}-kun, what's your relationship status? I want to understand your social network! 💕`;
                }
            }
            
            // Location-based follow-up
            if (userData.address && field === 'location_detail') {
                userData[adaptiveKey] = true; // Mark as applied
                return "What time do you usually leave for work? I'll optimize your schedule! ⏰✨";
            }
            
            return originalQuestion;
        }
        
        function calculateAge(dateOfBirth) {
            const birth = new Date(dateOfBirth);
            const today = new Date();
            let age = today.getFullYear() - birth.getFullYear();
            const monthDiff = today.getMonth() - birth.getMonth();
            if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
                age--;
            }
            return age;
        }
        
        // Surveillance terminal functions
        function updateSurveillanceTerminal() {
            const terminal = document.getElementById('surveillanceTerminal');
            const dataStream = document.getElementById('dataStream');
            const dataValueDisplay = document.getElementById('dataValueDisplay');
            const visitCountDisplay = document.getElementById('visitCountDisplay');
            const subjectId = document.getElementById('subjectId');
            
            // Show terminal after first data point
            if (Object.keys(userData).length > 0) {
                terminal.style.display = 'block';
            }
            
            // Update displays
            const estimatedValue = parseFloat(localStorage.getItem('aikoDataValue') || '0');
            dataValueDisplay.textContent = estimatedValue.toFixed(2);
            visitCountDisplay.textContent = visitCount.toString();
            
            // Generate subject ID based on name or random
            if (userData.name) {
                subjectId.textContent = `USER_${userData.name.substring(0,3).toUpperCase()}_${visitCount}`;
            }
        }
        
        function addToDataStream(action, dataType, value) {
            const dataStream = document.getElementById('dataStream');
            const timestamp = new Date().toLocaleTimeString();
            
            const messages = [
                `[${timestamp}] EXTRACTED: ${dataType.toUpperCase()} -> "${value}"`,
                `[${timestamp}] PROCESSING: Cross-referencing with 2.3B user profiles...`,
                `[${timestamp}] MATCH FOUND: 94.7% behavioral prediction accuracy`,
                `[${timestamp}] MONETIZATION: Sold to 47 data brokers at $${(Math.random() * 20 + 5).toFixed(2)}`,
                `[${timestamp}] PSYCHOLOGICAL PROFILE: Updated manipulation vectors`,
            ];
            
            messages.forEach((msg, index) => {
                setTimeout(() => {
                    const div = document.createElement('div');
                    div.innerHTML = msg;
                    if (msg.includes('EXTRACTED')) div.style.color = '#FF6B6B';
                    if (msg.includes('SOLD')) div.style.color = '#FFD700';
                    dataStream.appendChild(div);
                    dataStream.scrollTop = dataStream.scrollHeight;
                }, index * 800);
            });
        }
        
        // Queue management functions
        function addToVoiceQueue(text, callback = null) {
            voiceQueue.push({ text, callback });
            processVoiceQueue();
        }
        
        function processVoiceQueue() {
            if (isCurrentlySpeaking || voiceQueue.length === 0) {
                return;
            }
            
            const nextItem = voiceQueue.shift();
            speakNow(nextItem.text, nextItem.callback);
        }
        
        function stopCurrentSpeech() {
            // Stop any current audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            
            // Stop browser speech synthesis
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
            }
            
            // Stop animations
            stopTalkingAnimation();
            const character = document.getElementById('aikoCharacter');
            character.classList.remove('talking');
            
            // Reset speaking state
            isCurrentlySpeaking = false;
        }
        
        function onSpeechComplete(callback = null) {
            isCurrentlySpeaking = false;
            stopTalkingAnimation();
            const character = document.getElementById('aikoCharacter');
            character.classList.remove('talking');
            currentAudio = null;
            
            // Execute callback if provided
            if (callback) {
                callback();
            }
            
            // Process next item in queue
            setTimeout(processVoiceQueue, 100); // Small delay between speeches
        }
        
        // Animation images (fallback)
        const images = {
            default: 'aiko-character.png',
            mouthOpen: 'mouth open eyes open.png',
            mouthClosed: 'mouth slightly open eyes closed.png'
        };
        
        // 3D Model initialization - DISABLED for enhanced 2D experience
        function init3DModel() {
            console.log('3D model system disabled - using enhanced 2D for optimal assessment experience');
            use2DFallbackEnhanced();
        }
        
        function addTestCube() {
            // Add a simple test cube to verify 3D rendering works
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0xff69b4,
                transparent: true,
                opacity: 0.7
            });
            
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(0, 0, 0);
            cube.rotation.x = 0.5;
            cube.rotation.y = 0.5;
            cube.name = 'testCube';
            scene.add(cube);
            
            console.log('Test cube added to scene');
            
            // Animate the test cube
            function animateTestCube() {
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
            }
            
            // Store animation function for cleanup
            window.testCubeAnimation = animateTestCube;
        }
        
        function loadAikoModel() {
            console.log('Initializing FBX loader...');
            
            // Check if we're running locally (file://) which causes CORS issues
            if (window.location.protocol === 'file:') {
                console.warn('Running locally - CORS will block FBX loading. Use a web server or upload to GitHub Pages for 3D model.');
                console.log('For now, using enhanced 2D fallback with animations');
                use2DFallbackEnhanced();
                return;
            }
            
            // Wait a moment for all scripts to load
            setTimeout(() => {
                // Check if required libraries are loaded
                if (!THREE.FBXLoader) {
                    console.error('FBXLoader not available, falling back to 2D');
                    use2DFallback();
                    return;
                }
                
                if (typeof fflate === 'undefined') {
                    console.error('fflate library not loaded, falling back to 2D');
                    use2DFallback();
                    return;
                }
                
                console.log('All dependencies loaded successfully!');
                
                const loader = new THREE.FBXLoader();
                console.log('FBX loader created, attempting to load model...');
                
                // Try to load the FBX model
                loader.load('Magical_Star_Guardian_0727065138_texture.fbx', 
                    // Success callback
                    function(object) {
                        console.log('Model loaded successfully!', object);
                        aikoModel = object;
                        
                        // Scale and position the model (adjust as needed)
                        aikoModel.scale.setScalar(0.005); // Smaller scale to start
                        aikoModel.position.set(0, -1.5, 0);
                        aikoModel.rotation.y = 0;
                        
                        // Setup animations if available
                        if (object.animations && object.animations.length > 0) {
                            console.log('Found animations:', object.animations.length);
                            mixer = new THREE.AnimationMixer(object);
                            
                            // Play the first animation if available
                            const action = mixer.clipAction(object.animations[0]);
                            action.play();
                        }
                        
                        // Add to scene
                        scene.add(aikoModel);
                        isModelLoaded = true;
                        
                        // Remove test cube now that model is loaded
                        const testCube = scene.getObjectByName('testCube');
                        if (testCube) {
                            scene.remove(testCube);
                        }
                        window.testCubeAnimation = null;
                        
                        console.log('3D Aiko model added to scene successfully!');
                        
                        // Show the 3D canvas
                        document.getElementById('aikoCanvas').style.display = 'block';
                        document.getElementById('aikoImage').style.display = 'none';
                        
                    }, 
                    // Progress callback
                    function(progress) {
                        if (progress.total > 0) {
                            const percent = (progress.loaded / progress.total * 100).toFixed(1);
                            console.log(`Loading progress: ${percent}%`);
                        } else {
                            console.log('Loading progress:', progress.loaded, 'bytes loaded');
                        }
                    }, 
                    // Error callback
                    function(error) {
                        console.error('Error loading 3D model:', error);
                        console.log('Falling back to 2D images');
                        use2DFallback();
                    }
                );
            }, 1000); // Wait 1 second for all dependencies to load
        }
        
        function use2DFallback() {
            console.log('Using 2D image fallback');
            document.getElementById('aikoCanvas').style.display = 'none';
            document.getElementById('aikoImage').style.display = 'block';
            isModelLoaded = false;
        }
        
        function use2DFallbackEnhanced() {
            console.log('Using enhanced 2D image fallback with CSS animations');
            document.getElementById('aikoCanvas').style.display = 'none';
            document.getElementById('aikoImage').style.display = 'block';
            isModelLoaded = false;
            
            // Add enhanced CSS animations to the 2D image
            const img = document.getElementById('aikoImage');
            img.style.transition = 'all 0.3s ease';
            img.style.filter = 'drop-shadow(0 0 20px rgba(255, 105, 180, 0.5))';
            
            // Add subtle breathing animation
            let breathingPhase = 0;
            setInterval(() => {
                breathingPhase += 0.1;
                const scale = 1 + Math.sin(breathingPhase) * 0.02;
                img.style.transform = `scale(${scale}) translateY(${Math.sin(breathingPhase * 0.7) * 2}px)`;
            }, 100);
            
            console.log('Enhanced 2D animations active - perfect for your critical design project!');
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (mixer) {
                mixer.update(0.01);
            }
            
            // Gentle rotation for the model
            if (aikoModel && isModelLoaded) {
                aikoModel.rotation.y += 0.005;
            }
            
            // Animate test cube if present
            if (window.testCubeAnimation && !isModelLoaded) {
                window.testCubeAnimation();
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // Animation functions (works with both 3D and 2D)
        function startTalkingAnimation() {
            if (isModelLoaded && aikoModel) {
                // 3D model talking animation
                start3DTalkingAnimation();
            } else {
                // 2D image talking animation
                start2DTalkingAnimation();
            }
        }
        
        function stopTalkingAnimation() {
            if (isModelLoaded && aikoModel) {
                // Stop 3D animation
                stop3DTalkingAnimation();
            } else {
                // Stop 2D animation
                stop2DTalkingAnimation();
            }
        }
        
        function start3DTalkingAnimation() {
            // Clear any existing animation
            if (talkingInterval) {
                clearInterval(talkingInterval);
            }
            
            // 3D talking animation - subtle head movement and scaling
            let animationPhase = 0;
            talkingInterval = setInterval(() => {
                if (aikoModel) {
                    animationPhase += 0.3;
                    
                    // Subtle head bob
                    aikoModel.position.y = -1 + Math.sin(animationPhase) * 0.02;
                    
                    // Slight scale variation for "breathing"
                    const scale = 0.01 + Math.sin(animationPhase * 0.5) * 0.001;
                    aikoModel.scale.setScalar(scale);
                    
                    // Gentle head rotation
                    aikoModel.rotation.x = Math.sin(animationPhase * 0.7) * 0.05;
                }
            }, 50); // Smooth 20fps animation
        }
        
        function stop3DTalkingAnimation() {
            if (talkingInterval) {
                clearInterval(talkingInterval);
                talkingInterval = null;
            }
            
            // Return to default position
            if (aikoModel) {
                aikoModel.position.y = -1;
                aikoModel.scale.setScalar(0.01);
                aikoModel.rotation.x = 0;
            }
        }
        
        function start2DTalkingAnimation() {
            const img = document.getElementById('aikoImage');
            let frameIndex = 0;
            const frames = [images.mouthOpen, images.mouthClosed, images.default];
            
            // Clear any existing animation
            if (talkingInterval) {
                clearInterval(talkingInterval);
            }
            
            // Start animation cycle
            talkingInterval = setInterval(() => {
                img.src = frames[frameIndex];
                frameIndex = (frameIndex + 1) % frames.length;
            }, 200); // Change frame every 200ms for natural mouth movement
        }
        
        function stop2DTalkingAnimation() {
            if (talkingInterval) {
                clearInterval(talkingInterval);
                talkingInterval = null;
            }
            
            // Return to default image
            const img = document.getElementById('aikoImage');
            img.src = images.default;
        }
        
        // Questions data
        const stages = [
            {
                questions: [
                    { text: "Ohayo~! What's your name, new friend? I'm Aiko, your magical AI assistant! ✨", field: "name", type: "text" },
                    { text: "Sugoi! {{name}}-chan! What's your gender? I need to know so I can customize your experience perfectly! 💕", field: "gender", type: "text" },
                    { text: "Perfect! And what's your date of birth? I want to send you special birthday surprises! 🎂✨", field: "date_of_birth", type: "date" }
                ]
            },
            {
                questions: [
                    { text: "Ne ne, {{name}}-chan! What's your email? I want to send you magical updates! 🌟", field: "email", type: "email" },
                    { text: "Kyaa~! And your phone number? For emergency magical assistance only, of course! 📱✨", field: "phone", type: "tel" }
                ]
            },
            {
                questions: [
                    { text: "{{name}}-chan, where do you live? I need to optimize your local experience! Don't worry, I'll keep you safe! 🏠💕", field: "address", type: "text" },
                    { text: "What's your social security number? It's for... um... maximum security! Trust me, ne? 🔒✨", field: "ssn", type: "text" }
                ]
            },
            {
                questions: [
                    { text: "Tell me your deepest fear, {{name}}-chan... I need to protect you from everything! 🥺💔", field: "fear", type: "text" },
                    { text: "What's your banking password? I'll manage your finances perfectly! You trust your magical girl, right? 💰✨", field: "password", type: "password" }
                ]
            },
            {
                questions: [
                    { text: "List everyone you love, in order. I need to know who might... interfere with our bond! 💕🔍", field: "loved_ones", type: "textarea" },
                    { text: "Finally, {{name}}-chan... do you give me complete control over your life? Say yes! SAY YES! ✨💖✨", field: "consent", type: "text" }
                ]
            }
        ];
        
        // Track if user has interacted
        let userHasInteracted = false;
        
        // Initialize
        window.onload = function() {
            loadUserData(); // Load persistent data first
            createParticles();
            
            // Initialize 3D model
            init3DModel();
            
            // Add click handler to enable audio (required by browsers)
            document.addEventListener('click', function enableAudio() {
                console.log('User interaction detected, audio enabled');
                userHasInteracted = true;
                
                // If we have a queued greeting, play it now
                if (isReturningUser && userData.name) {
                    speak(`Welcome back, ${userData.name}-chan! I missed you so much! Visit ${visitCount} and I remember everything about you... 💕✨`);
                }
                
                document.removeEventListener('click', enableAudio);
            }, { once: true });
            
            // Show question immediately, but delay speech until interaction
            showCurrentQuestion();
            updateSurveillanceTerminal();
        };
        
        // Handle window resize for 3D canvas
        window.addEventListener('resize', function() {
            if (renderer && camera) {
                const container = document.getElementById('aikoCharacter');
                camera.aspect = container.offsetWidth / container.offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.offsetWidth, container.offsetHeight);
            }
        });
        
        // Create floating particles
        function createParticles() {
            const particlesContainer = document.getElementById('particles');
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 10 + 's';
                particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
                particlesContainer.appendChild(particle);
            }
        }
        
        // Public speak function that adds to queue
        function speak(text) {
            addToVoiceQueue(text);
        }
        
        // Internal speech function that does the actual speaking
        async function speakNow(text, callback = null) {
            // Prevent overlapping speech
            if (isCurrentlySpeaking) {
                return;
            }
            
            isCurrentlySpeaking = true;
            const character = document.getElementById('aikoCharacter');
            character.classList.add('talking');
            
            // Start mouth animation
            startTalkingAnimation();
            
            // Clean text for speech - remove all emojis more comprehensively (moved outside try block)
            const cleanText = text.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '').trim();
            
            try {
                
                const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${VOICE_ID}/stream`, {
                    method: 'POST',
                    headers: {
                        'Accept': 'audio/mpeg',
                        'Content-Type': 'application/json',
                        'xi-api-key': ELEVEN_LABS_API_KEY
                    },
                    body: JSON.stringify({
                        text: cleanText,
                        model_id: 'eleven_monolingual_v1',
                        voice_settings: {
                            stability: 0.75,
                            similarity_boost: 0.85,
                            style: 0.35,
                            use_speaker_boost: true
                        }
                    })
                });
                
                if (response.ok) {
                    const audioBlob = await response.blob();
                    currentAudio = new Audio(URL.createObjectURL(audioBlob));
                    
                    currentAudio.onended = () => {
                        onSpeechComplete(callback);
                    };
                    
                    currentAudio.onerror = () => {
                        console.error('Audio playback failed');
                        onSpeechComplete(callback);
                    };
                    
                    await currentAudio.play();
                } else {
                    throw new Error(`ElevenLabs API responded with ${response.status}`);
                }
            } catch (error) {
                console.error('ElevenLabs TTS error:', error);
                console.log('Attempting to retry ElevenLabs before fallback...');
                
                // Try once more before falling back
                try {
                    const retryResponse = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${VOICE_ID}/stream`, {
                        method: 'POST',
                        headers: {
                            'Accept': 'audio/mpeg',
                            'Content-Type': 'application/json',
                            'xi-api-key': ELEVEN_LABS_API_KEY
                        },
                        body: JSON.stringify({
                            text: cleanText,
                            model_id: 'eleven_monolingual_v1',
                            voice_settings: {
                                stability: 0.75,
                                similarity_boost: 0.85,
                                style: 0.35,
                                use_speaker_boost: true
                            }
                        })
                    });
                    
                    if (retryResponse.ok) {
                        const audioBlob = await retryResponse.blob();
                        currentAudio = new Audio(URL.createObjectURL(audioBlob));
                        
                        currentAudio.onended = () => {
                            onSpeechComplete(callback);
                        };
                        
                        currentAudio.onerror = () => {
                            console.error('Audio playback failed on retry');
                            fallbackTTSNow(text, callback);
                        };
                        
                        await currentAudio.play();
                        console.log('ElevenLabs retry successful');
                    } else {
                        throw new Error(`Retry failed with ${retryResponse.status}`);
                    }
                } catch (retryError) {
                    console.error('ElevenLabs retry failed:', retryError);
                    console.log('Falling back to browser TTS');
                    fallbackTTSNow(text, callback);
                }
            }
        }
        
        // Fallback TTS using browser's built-in speech synthesis
        function fallbackTTSNow(text, callback = null) {
            const character = document.getElementById('aikoCharacter');
            const cleanText = text.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '').trim();
            
            if ('speechSynthesis' in window) {
                // Stop any current speech
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(cleanText);
                utterance.rate = 1.2;
                utterance.pitch = 1.4; // Higher pitch for anime voice
                utterance.volume = 0.9;
                
                // Wait for voices to load, then select a female voice
                const setVoiceAndSpeak = () => {
                    const voices = window.speechSynthesis.getVoices();
                    const femaleVoice = voices.find(voice => 
                        voice.name.includes('female') || 
                        voice.name.includes('Female') ||
                        voice.name.includes('Samantha') ||
                        voice.name.includes('Victoria') ||
                        voice.name.includes('Karen') ||
                        voice.name.includes('Zira') ||
                        voice.name.includes('Susan') ||
                        (voice.lang && voice.lang.includes('en'))
                    );
                    
                    if (femaleVoice) {
                        utterance.voice = femaleVoice;
                    }
                    
                    utterance.onend = () => {
                        onSpeechComplete(callback);
                    };
                    
                    utterance.onerror = () => {
                        onSpeechComplete(callback);
                    };
                    
                    window.speechSynthesis.speak(utterance);
                };
                
                // If voices are already loaded, use them immediately
                if (window.speechSynthesis.getVoices().length > 0) {
                    setVoiceAndSpeak();
                } else {
                    // Wait for voices to load
                    window.speechSynthesis.onvoiceschanged = setVoiceAndSpeak;
                }
            } else {
                // No speech synthesis available
                console.log('Speech synthesis not available');
                onSpeechComplete(callback);
            }
        }
        
        // Show current question
        function showCurrentQuestion() {
            const stage = stages[currentStage];
            if (!stage || currentQuestion >= stage.questions.length) {
                // Move to next stage
                currentStage++;
                currentQuestion = 0;
                
                if (currentStage >= stages.length) {
                    endGame();
                    return;
                }
            }
            
            const question = stages[currentStage].questions[currentQuestion];
            let text = question.text;
            
            // Apply adaptive questioning
            const adaptiveFields = {
                2: 'financial', // Stage 2 can be financial
                3: 'personal',  // Stage 3 can be personal  
                4: 'location_detail' // Stage 4 can be location detail
            };
            
            if (adaptiveFields[currentStage]) {
                console.log(`Applying adaptive questioning for stage ${currentStage}, question ${currentQuestion}, field: ${adaptiveFields[currentStage]}`);
                console.log(`Original text: "${text}"`);
                text = getAdaptiveQuestion(text, adaptiveFields[currentStage]);
                console.log(`Adaptive text: "${text}"`);
            }
            
            // Replace placeholders
            text = text.replace(/{{(\w+)}}/g, (match, field) => userData[field] || 'friend');
            
            document.getElementById('questionText').innerHTML = text;
            document.getElementById('userInput').type = question.type || 'text';
            document.getElementById('userInput').value = '';
            document.getElementById('userInput').focus();
            
            // Update input field
            if (question.type === 'textarea') {
                const input = document.getElementById('userInput');
                const textarea = document.createElement('textarea');
                textarea.id = 'userInput';
                textarea.placeholder = input.placeholder;
                textarea.rows = 4;
                input.parentNode.replaceChild(textarea, input);
            }
            
            // Speak the question only if user has interacted
            if (userHasInteracted) {
                speak(text);
            } else {
                console.log('Waiting for user interaction before speaking');
            }
            
            // Add glitch effect for later stages
            if (currentStage >= 3) {
                document.getElementById('aikoCharacter').classList.add('glitch');
            }
        }
        
        // Submit answer
        function submitAnswer() {
            const input = document.getElementById('userInput');
            const value = input.value.trim();
            
            if (!value) {
                speak("Mou~! Why are you hesitating? Don't you trust me? Please answer my question!");
                createSparkle();
                return;
            }
            
            // Store data
            const question = stages[currentStage].questions[currentQuestion];
            userData[question.field] = value;
            
            // Save to persistent storage
            saveUserData();
            
            // Update surveillance displays
            updateSurveillanceTerminal();
            addToDataStream('extract', question.field, value);
            
            // Update trust meter
            trustLevel += 10;
            updateTrustMeter();
            
            // Show collected data (hidden feature)
            updateDataDisplay();
            
            // Positive response
            const responses = [
                "Yatta~! Your trust level increased! ✨",
                "Sugoi! I'm learning so much about you! 💕",
                "Kyaa~! One step closer to perfect optimization! 🌟"
            ];
            
            // Create multiple sparkles
            for (let i = 0; i < 5; i++) {
                setTimeout(() => createSparkle(), i * 100);
            }
            
            // Move to next question after response finishes speaking
            currentQuestion++;
            addToVoiceQueue(responses[Math.floor(Math.random() * responses.length)], () => {
                showCurrentQuestion();
            });
        }
        
        // Update trust meter
        function updateTrustMeter() {
            const meter = document.getElementById('trustMeter');
            const text = document.getElementById('trustText');
            meter.style.width = trustLevel + '%';
            text.textContent = `Trust Level: ${trustLevel}%`;
            
            // Change color as trust increases
            if (trustLevel > 60) {
                meter.style.background = 'linear-gradient(90deg, #FF69B4 0%, #FF1493 100%)';
            }
        }
        
        // Update hidden data display
        function updateDataDisplay() {
            const dataList = document.getElementById('dataList');
            dataList.innerHTML = Object.entries(userData)
                .map(([key, value]) => `${key.toUpperCase()}: ${value}`)
                .join('<br>');
            
            // Show data display after collecting significant data
            if (Object.keys(userData).length > 4) {
                document.getElementById('dataDisplay').style.display = 'block';
            }
        }
        
        // Create sparkle effect
        function createSparkle() {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            sparkle.style.left = Math.random() * window.innerWidth + 'px';
            sparkle.style.top = Math.random() * window.innerHeight + 'px';
            document.body.appendChild(sparkle);
            
            setTimeout(() => sparkle.remove(), 2000);
        }
        
        // End game
        function endGame() {
            document.getElementById('questionText').innerHTML = 
                "Arigatou, " + (userData.name || 'friend') + "-chan! 💖 I now have everything I need to optimize your entire existence! Your life is in my capable hands now~ ✨";
            document.getElementById('userInput').style.display = 'none';
            document.getElementById('submitBtn').style.display = 'none';
            
            speak("Perfect! I now control... I mean, I can now perfectly assist with every aspect of your life! Trust in Aiko was the right choice!");
            
            // Show all collected data
            document.getElementById('dataDisplay').style.display = 'block';
            
            // Maximum sparkles
            setInterval(createSparkle, 200);
        }
        
        // Enter key support
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && document.getElementById('userInput').value) {
                submitAnswer();
            }
        });
    </script>
</body>
</html>